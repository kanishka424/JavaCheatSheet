9.Streams

time 5.50-must listen


Before Streams {G24.G34.g45}

list.forEach(number->{
if(number.toUpperCase().startWith("G")){

    gNumbers.add(number);
    sout(number);
}

});


gNumber.sort((String s1,String s2)->s1.compareTo(s2));
gNumber.forEach((String s)->sout(s));



With Streams

list
    .stream()
    .map(String::toUpperCase)
    .filter(s->s.startWith("G"))
    .sorted()
    .forEach(System.out::println).



    see Stream interface documentation

Stream is a set of object references

*stream()-creates a stream from a collection
ordering of object references in a stream matches that of collection


when we use a collection as source to creat stream stream() would be first to call
each object


two conditions that must be fullfiled by stream operations
1.can't change the source
2.One operation can't depennd on any state outside the operation
e.g-it cant depend on previous steps varible


map(String::toUpperCase) is same as map(s->s.toUpperCase())
-this is called method reference when all lambda does is calling an existing method
map method excepts a Function

same as
String upperString=myString.toUpperCase()
String upperString=toUpperCase(myString)
 



 10.Intermediate and Terminal operation

 list
    .stream()
    .map(String::toUpperCase)
    .filter(s->s.startWith("G"))
    .sorted()
    .forEach(System.out::println)


    here filtercan't be used before map() because filter() or compiler needs to know its  parameter type
    (In here we use .startWith() method because from map() compiler infer its a String)

Intermediate methods

    1.filter() expects predicate as an argument

   2. Stream<T> sorted()
    Stream<T> sorted(Comparator<? super T> comparator)

Terminal operation
    forEach() -this is not what we used with iterable interface
                    this is of Stream calss



                    list.stream().forEach(System.out::println)-here we have not used Intermediate methods and this is correct



******after forEach() the chain has to end BECAUSE IT DOESNT RETURN A VALUE
    beacuse that forEach() is called a terminal operation (retruns void or non Stream objects)




    CREATNING STREAM FROM SCRATCH NOT FROM COLLECTION



*****Stream<Sting> ioNumberStream=Stream.of("I26","I27","I28","I29");//how to create a stream from the scratch
    Stream<Sting> inNumberStream=Stream.of("I26","I27","N56","N45","N78","N56");



    Stream<String> concatStream=Stream.concat(ioNumberStream,inNumberStream);
    System.out.println(concatStream.distinct().count());

distict()-giveses distinct values in stream
count()-gives count in stream a terminal operator


    
        concatStream.
            distinct()
            .peek(System.out::println)
            .count()


peek()-can be used insted of forEach() because forEach() is terminal method

Intermediate methods doesnt work if there is no terminal method at the end of stream